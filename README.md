## Устные вопросы

1.  Какой самый эффективный способ конкатенации строк?

    Так как строки представляют собой неизменяемый слайс байтов, при конкатенации двух строк происходит выделение новой памяти. Это может негативно сказаться на потреблении памяти, если нужно соединить много строк. Поэтому в таких случаях следует использовать `strings.Builder`.

    ```go
    var b strings.Builder
    b.Grow(100)
    for i := 0; i<100; i++ {
        fmt.Fprint(&b, "a")
    }
    fmt.Println(b.String())
    ```

2.  Что такое интерфейсы, как они применяются в Go?

    Интерфейсы — это инструменты для определения наборов действий и поведения. Интерфейсы — это в первую очередь контракты. Они позволяют объектам опираться на абстракции, а не фактические реализации других объектов. При этом для компоновки различных поведений можно группировать несколько интерфейсов. В общем смысле — это набор методов, представляющих стандартное поведение для различных типов данных.

    **Как устроен Duck-typing в Go?**

    Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, утка и есть.

    Если структура содержит в себе все методы, что объявлены в интерфейсе, и их сигнатуры совпадают — она автоматически удовлетворяет интерфейс.

    Такой подход позволяет полиморфно (полиморфизм — способность функции обрабатывать данные разных типов) работать с объектами, которые не связаны в иерархии наследования. Достаточно, чтобы все эти объекты поддерживали необходимый набор методов.


    **Алиас**

    Для лучшей читаемости кода в Go был добавлен тип `any`, являюшийся алиасом пустого интерфейса.

    ```go

        any = interface{}

    ```

    **Использование в дженериках**

    Для реализации функций, использующих дженерики, можно созать специальные типы на основе интерфейсов.
    Пример:

    ```go     
    package main

    import "fmt"

    type Number interface {
        int | float64
    }

    func Sum[V Number](a, b V) V {
        return a + b
    }

    func main() {
        a, b := 1, 2
        fmt.Println(Sum[int](a, b)) // используем Sum для Int

        c, d := 1.2, 3.4
        fmt.Println(Sum[float64](c, d)) // используем Sum для Floats
    }
    ```

    **Пустой interface{}**

    Ему удовлетворяет вообще любой тип. Пустой интерфейс ничего не означает, никакой абстракции. Поэтому использовать пустые интерфейсы нужно в самых крайних случаях.

    На какой стороне описывать интерфейс — на передающей или принимающей?

    Многое зависит от конкретного случая, но по умолчанию описывать интерфейсы следует на принимающей стороне — таким образом, ваш код будет меньше зависеть от какого-то другого кода/пакета/реализации.

    Другими словами, если нам в каком-то месте требуется «что-то что умеет себя закрывать», или — умеет метод Close() error, или (другими словами) удовлетворят интерфейсу:

    ```go
    type something interface {
        Close() error
    }
    ```

    То он (интерфейс) должен быть описан на принимающей стороне. Так принимающая сторона не будет ничего знать о том, что именно в неё может «прилететь», но точно знает поведение этого «чего-то». Таким образом реализуется инверсия зависимости, и код становится проще переиспользовать/тестировать.

3.  Чем отличаются `RWMutex` от `Mutex`?

    `Mutex` позволяет блокировать доступ к общим ресурсам с помощью методов `Lock` и `Unlock`. У `RWMutex` есть еще два метода `RLock` и `RUnlock`, которые можно использовать, если общий ресурс нуждается в чтении, таким образом другие операции `RLock/RUnlock` не заблокируются, а операции `Lock/Unlock` заблокируются.

4.  Чем отличаются буферизированные и не буферизированные каналы?

    Чтение или запись данных в небуферизированный канал блокирует горутину и контроль передается свободной горутине. Буферизированный канал создается указанием размера буфера, в этом случае горутина не блокируется до тех пор, пока буфер не будет заполнен.

5.  Какой размер у структуры `struct{}{}`?

    Пустая структура занимает 0 байт.

6.  Есть ли в Go перегрузка методов или операторов?

    Нет.

7.  В какой последовательности будут выведены элементы `map[int]int`?
    Пример:

    ```go
    m[0]=1
    m[1]=124
    m[2]=281
    ```

    В случайной. Порядок вывода при итерации по мапе не гарантирован.

8.  В чем разница `make` и `new`?

    Функция `new(T)` выделяет «нулевую» память для нового элемента типа `T` и возвращает его адрес, значение типа `*T`. В терминологии Go он возвращает указатель на только что выделенное нулевое значение типа `T`. Вот три различных способа создания указателя `p`, указывающего на нулевое значение `bytes.Buffer`, каждый из которых эквивалентен:

    ```go
    var buf bytes.Buffer
    p := &buf

    p := &bytes.Buffer{}

    p := new(bytes.Buffer)
    ```

    Функция `make()` — это специальная встроенная функция, которая используется для инициализации слайсов, мап и каналов. `make()` можно использовать только для инициализации слайсов, мап и каналов, и что, в отличие от функции `new()`, `make()` не возвращает указатель.

    Слайсы, мапы и каналы также можно инициализировать с помощью составных выражений. В качестве примеров ниже приведены два разных (но эквивалентных) способа инициализации мапы `m`:

    ```go
    m := make(map[string]bool, 0)

    m := map[string]bool{}
    ```

    Также можно инициализировать мапу и заполнить ее значениями:

    ```go
    m := map[string]bool{
    "java": false,
    "go": true,
    }
    ```

9.  Сколько существует способов задать переменную типа `slice` или `map`?

    ```go
    // slice - 6
    letters := []string{}
    letters := []string{"a", "b", "c", "d"}
    var letters []string
    letters := make([]string, 0)
    letters := make([]string, 0, 1)
    letters := new([]string)

    // map - 5
    var m map[string]string
    m := map[string]string{
        "2": "1",
        "1": "2",
    }
    m := make(map[string]string)
    m := make(map[string]string, 10)
    m := new(map[string]string)
    ```

10. Что выведет данная программа и почему?

    ```go
    func update(p *int) {
        b := 2
        p = &b
    }

    func main() {
        var (
            a = 1
            p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
    }
    ```

    По-умолчанию в go аргументы в функцию передаются по значению. Если необходимо передать указатель, нужно это явно указать. Однако в go нет ссылок (не возможно создать две переменные с одним адресом). В примере выше, несмотря на то, что в функцию `update` передается указатель, переменная в главной функции не изменяется. Обе переменные `p` указывают на один и тот же адрес, но это две разные переменные, поэтому из функции `update` мы не можем обновить переменную `p` в главной функции.

    Таким образом программа выведет:

    ```
    1
    1
    ```

    Для того, чтобы исправить эту ошибку, нужно вернуть из функции `update` переменную `p` и в главной функции присвоить результат переменной `p`.

11. Что выведет данная программа и почему?

    ```go
    func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
    }
    ```

    В анонимную функцию `WaitGroup` передан не по ссылке, а по значению, поэтому он копируется.
    Из-за этого вызов `wg.Wait()` не повлияет на изначальную `WaitGroup`у и счетчик в главной функции не поменяется.

    Ответ: главная функция зависнет навсегда и будет дедлок. Исправить можно передав `WaitGroup` по указателю.


12. Что выведет данная программа и почему?

    ```go
    func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
    }
    ```

    Программа выведет 0. Конструкция `if` создает новую область видимости, переменная `n` создается в ней и инкрементируется. 
    При этом переменная `n` конструкции `if` не затрагивается, так как она находится в другой области видимости.

13. Что выведет данная программа и почему?

    ```go
    func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
    }

    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
    }
    ```

    Программа выведет: `[100 2 3 4 5]`

    Слайс – это структура, которая содержит в себе длину, емкость и указатель на массив. 
    Передавая слайс в функцию по значению, он копируется, но поля остаются теми же. Поэтому мы можем изменить значения элементов.
    Функция `append` добавляет элементы в слайс и возвращает новый.

14. Что выведет данная программа и почему?

    ```go
    func main() {
        slice := []string{"a", "a"}
        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
    }
    ```

    Программа выведет: `[b b a][a a]`

    В данной программе анонимной функции передается через параметры слайс, то есть он копируется. Меняя этот слайс мы не меняем слайс в главной функции.
